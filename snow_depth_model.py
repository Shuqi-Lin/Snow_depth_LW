# -*- coding: utf-8 -*-
"""Snow Depth model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wMPCUzKjqqAGVNRhkj8GDOuRkaufOnzd

@author: LinS
"""
#%% General packages
import netCDF4 as nc
import os
import pandas as pd
import numpy as np

import datetime as dt
import matplotlib.pyplot as plt
import time
import math
import random
#%% Load Meteorological data from RDPS"""
os.chdir('C://Users//LinS//Documents//ECCC//3-Model-LW//GitHub//Snow_depth_LW')
os.chdir('./RDPS')
os.getcwd()

"""# Physical snow model

For melt during rainy periods:

M = C[.09 + (.029 + .00504v + .007P) (Ta - TF)]

where:

M = melt (inches/day)

v = wind speed (miles/hour) 50 feet above the snow surface

Ta = air temperature (°F)

TF = freezing temperature (°F, allowed to vary from 32 °F for spatial and temporal fluctuations)

P = rainfall (inches/day)

C = coefficient to account for variations
"""

def snow_model(air_temp,wind_spd,prec,parameters,C):
  ## air_temp is in C degree, wind_spd is in m/s, prec is in m/day.
  ## Parameters contain 5 parameters corresponding to the rate of snow generation under different temperature. They are adjustable depending on site characteristics
  if (air_temp<0)&(air_temp>=-3):
    snow = prec*parameters[0]
  elif (air_temp<-3)&(air_temp>=-7):
    snow = prec*parameters[1]
  elif (air_temp<-7)&(air_temp>=-13):
    snow = prec*parameters[2]
  elif (air_temp<-13)&(air_temp>=-29):
    snow = prec*parameters[3]
  elif air_temp<-29:
    snow = prec*parameters[4]
  else:
    snow = -C[0]*(0.09+0.00504*wind_spd*2.24+0.007*prec*39.37)*(air_temp-0)*25.4/1000
  return snow

def read_Meteo_file(stn,year):
  Met = pd.read_csv('RDRSv21_LW_met_'+stn+'_'+year+'.csv',skiprows = 3,sep = ',')
  Met['DATE'] = Met['TIME'].apply(lambda t:dt.datetime.strptime(str(t),'%Y%j').date())
  Met['DATE'] = pd.to_datetime(Met['DATE'])
  #Met.drop(['TIME'],inplace = True)
  return Met

Meteo = pd.DataFrame()
stn = input('STN? (e.g.,500, 502, 505)')
num_yr = int(input('Number of years?'))
start_yr = input('Start from year? (eg. 2017)')
for n in range(num_yr):
  year = str(int(start_yr)+n)
  meteo = read_Meteo_file(stn,year)
  ## Concatenate multiple years data
  Meteo = pd.concat([Meteo,meteo],axis = 0)


## Compute rolling mean values of air temperature and precipitation of previous week (optional, may be useful for ML models)
Meteo['AIR_TEMP_mean'] = Meteo['AIR_TEMP'].rolling(7,min_periods=1).mean()
Meteo['Tot Prec_mean'] = Meteo['PRECIP'].rolling(7,min_periods=1).mean()

## Initiate Snow depth
Meteo['SNOW'] = 0

def SD_calculation(Meteo,snow_on,snow_off,parameters,C):
  Meteo.loc[(Meteo['DATE']>snow_on)&(Meteo['DATE']<=snow_off),'SNOW_diff'] = Meteo.loc[(Meteo['DATE']>snow_on)&(Meteo['DATE']<=snow_off)].apply(lambda r:snow_model(r['AIR_TEMP'],r['WIND_SPEED'],r['PRECIP'],parameters,C),
                                                      axis = 1,result_type = 'reduce')
  #Meteo['Accum_snow'] = Meteo['SNOW_diff'].cumsum()
  Meteo.loc[(Meteo['DATE']>snow_on)&(Meteo['DATE']<=snow_off),'Accum_snow'] = Meteo.loc[(Meteo['DATE']>snow_on)&(Meteo['DATE']<=snow_off),'SNOW_diff'].cumsum()
  Meteo.loc[Meteo['Accum_snow']>0,'SNOW'] = Meteo.loc[Meteo['Accum_snow']>0,'Accum_snow']
  return Meteo

#%% Parameters Calibration Machine

from sklearn.metrics import mean_squared_error, mean_absolute_error,r2_score
# Use 2017-2018 season snow depth to calibrate the model
snow_on = pd.Timestamp(2017,11,1)
snow_off = pd.Timestamp(2018,5,15)
Timeseries = pd.DataFrame({'DATE':pd.date_range(snow_on,snow_off)})
Metrics = pd.DataFrame(columns = ['Parameters','C','RMSE','R2'])
# Locate to the file folder (Load snow depth data from HRDPS model)
os.chdir('../HRDPS') #../HRDPS
os.getcwd()

def read_snow_file(stn,year,Timeseries):
  SD = pd.read_csv('HRDPS_LW_snowdepth_'+stn+'_'+year+'.csv',sep = '\t',usecols = [0,1])
  SD.columns = ['DATE','SD']
  SD['SD'] = SD['SD']/100 # Convert unit to m
  SD['DATE'] = pd.to_datetime(SD['DATE'])
  SD = SD.merge(Timeseries,on = 'DATE',how = 'right')
  SD['SD'].interpolate(method = 'linear',inplace = True)
  return SD
# Load snow depth
year = '2017-2018' #input('Year? (eg. 2017-2018)')
SD = read_snow_file(stn,year,Timeseries)

for i in range(1500):
  p1 = random.sample([10,20,30], 1)
  p2 = random.sample([20,30,40,50], 1)
  while p2<p1:
    p2 = random.sample([20,30,40,50], 1)

  p3 = random.sample([50,60,70,80,90],1)
  while p3<p2:
    p3 = random.sample([50,60,70,80,90],1)

  p4 = random.sample([80,90,100,110,120],1)
  while p4<p3:
    p4 = random.sample([80,90,100,110,120],1)

  p5 = random.sample([100,110,120,130,140,150],1)
  while p5<p4:
    p5 = random.sample([100,110,120,130,140,150],1)
  C = random.sample(list(np.arange(1,6,0.1)),1) # Station 505 use [1.2]
  parameters = list(p1+p2+p3+p4+p5)
  Meteo = SD_calculation(Meteo,snow_on,snow_off,parameters,C)
  Eval = Meteo.merge(SD, on = 'DATE',how = 'inner')[['DATE','SNOW','SD']]
  Eval.columns = ['DATE','PRED','TRUE']
  R2 = np.round(r2_score(Eval['PRED'],Eval['TRUE']),2)
  RMSE = mean_squared_error(Eval['PRED'],Eval['TRUE'],squared = False)
  df = pd.DataFrame({'Parameters':[parameters],'C':C,'R2':R2,'RMSE':RMSE})
  Metrics = pd.concat([Metrics,df],axis=0)

Metrics.plot(x = 'RMSE',y = 'R2',style = 'ro')

## Choose the parameter set with best performance
r2_max = Metrics['R2'].max()
print('Max R2: {}'.format(np.round(r2_max,2)))
r2_threshold = r2_max-0.05
rmse_min = np.round(Metrics[Metrics['R2']>=r2_threshold]['RMSE'].min(),3)
print('Min RMSE: {}'.format(rmse_min))
rmse_threshold = rmse_min+0.005
parameters = list(Metrics[(Metrics['R2']>=r2_threshold)&(Metrics['RMSE']<=rmse_threshold)]['Parameters'])
# Thresholds are adjustable
while len(parameters)>=2:
  r2_threshold +=0.001
  if r2_threshold>r2_max:
    break
  rmse_threshold-=0.0005
  if rmse_threshold<rmse_min:
    break
  parameters = list(Metrics[(Metrics['R2']>=r2_threshold)&(Metrics['RMSE']<=rmse_threshold)]['Parameters'])#[0]
print(r2_threshold)
print(rmse_threshold)
print(parameters)
print(C)
parameters = parameters[0] # Choose the first set in the pool

#%% Model snowdepth in rest of years

for n in range(num_yr):
    year = str(int(start_yr)+n)
    if year =='2002':
        snow_on = pd.Timestamp(int(year),1,1)
        snow_off = pd.Timestamp(int(year)+1,5,15)
    else:
        snow_on = pd.Timestamp(int(year),11,1)
        snow_off = pd.Timestamp(int(year)+1,5,15)
   
    Meteo = SD_calculation(Meteo,snow_on,snow_off,parameters,C)

Meteo.plot(x = 'DATE',y = 'SNOW',figsize = (10,4))

"""## Model evaluation (calibrate against 2017-2018 season, validate against 2018-2019 season)"""

# Locate to the file folder (Load snow depth data from HRDPS model)
os.chdir('../HRDPS') #../HRDPS
os.getcwd()

# Load snow depth
year = '2017-2018' #input('Year? (eg. 2017-2018)')
snow_on = pd.Timestamp(2017,11,1)
snow_off = pd.Timestamp(2018,5,15)
Timeseries = pd.DataFrame({'DATE':pd.date_range(snow_on,snow_off)})
SD_cal = read_snow_file(stn,year,Timeseries)

year = '2018-2019'
snow_on = pd.Timestamp(2018,11,1)
snow_off = pd.Timestamp(2019,5,15)
Timeseries = pd.DataFrame({'DATE':pd.date_range(snow_on,snow_off)})
SD_val = read_snow_file(stn,year,Timeseries)

Eval = Meteo.merge(SD_cal, on = 'DATE',how = 'left')[['DATE','SNOW','SD']]
Eval.columns = ['DATE','PRED','TRUE']
f,ax = plt.subplots(figsize = (12,4))
Eval.plot(x = 'DATE',y = ['PRED','TRUE'],ax = ax,
          label = ['Model','Calibration'])
print('Calibration R2: {}'.format(np.round(r2_score(Eval.dropna()['PRED'],Eval.dropna()['TRUE']),2)))

Eval = Meteo.merge(SD_val, on = 'DATE',how = 'left')[['DATE','SNOW','SD']]
Eval.columns = ['DATE','PRED','TRUE']
Eval.plot(x = 'DATE',y = 'TRUE',ax = ax,label = 'Validation')
ax.set_title('STN '+stn+' (Calibrate against 2017-2018, validate against 2018-2019)')
print('validation R2: {}'.format(np.round(r2_score(Eval.dropna()['PRED'],Eval.dropna()['TRUE']),2)))

Vars = ['TIME','WIND_SPEED','WIND_DIR','AIR_TEMP','REL_HUM','SOLAR_RAD','LW_RAD_IN','ATM_PRESS','PRECIP','SNOW']
prec = 'PRECIP'
snow = 'SNOW'
Meteo = Meteo.merge(SD,on = 'DATE',how = 'left')
## Replace the model values with HRDPS values
Meteo.loc[np.isnan(Meteo['SD']),'SD'] = Meteo.loc[np.isnan(Meteo['SD']),'SNOW']
Meteo.drop('SNOW',axis = 1,inplace = True)
Meteo.rename(columns={'SD':'SNOW'},inplace = True)
#f2,ax = plt.subplots(figsize = (12,5))
#Meteo.plot(x = 'DATE',y = 'SNOW',ax = ax)
#f2.savefig('Snow depth model_'+stn+'.png',dpi = 500)
def input_preparation(Met,var,prec,snow):
  file = Met[var]
  file.loc[file[snow]>0,prec] = 0
  file.rename(columns = {prec:'RAIN'},inplace= True)
  return file

Met = input_preparation(Meteo,Vars,prec,snow)
Met.to_csv('Meteo_'+stn+'_2002-2018.csv',index = False,sep = '\t')
os.chdir('..')
f.savefig('Snow depth model_'+stn+'.png',dpi = 500)